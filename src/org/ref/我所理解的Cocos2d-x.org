#+STARTUP: INDENT NUM
#+PROPERTY: header-args:c++ :exports both :results output

* 全新的Cocos2d-x 3.0
1. 采用了C++式的代码命名风格
   - 使用命名空间代替CC前缀
   - 使用C++强枚举类型代表常量
   - 使用了c++11的一些新的语法机制, 比如std::move, override等等
2. 将渲染从ui树之中分离, 可以更灵活的调整渲染顺序, 优化渲染代码
   - 首先遍历ui树, 并依遍历顺序将每个ui的处理作为一个绘制命令发送到渲染栈
   - 优化渲染栈的渲染顺序, 比如合并相同渲染, 批处理渲染, 渲染裁剪等
3. 放弃和cocos2d-iphone进行api同步, 采用独立变化的策略
4. 增加了新的统一消息分发机制
5. 深度整合物理引擎, 无需了解物理引擎的细节就可以方便地使用物理引擎
6. 使用了TTF库重写了字体部分, 支持了更多的字体特效以及功能
7. 提供了大量的可扩展的官方GUI控件

* Cocos2d-x 架构一瞥
1. 架构系统总览
   |                     游戏                     |
   |   动画系统   |  事件系统  |  控件  |  三方工具   |
   |                    渲染系统                  |
   |   核心系统   |  资源  |   音频  |   物理引擎    |
   |      平台独立层       |        |              |
   |      第三方库        |        |              |
   | ios | android | osx | windows | ubuntu     |
2. 内存管理机制
   - 对于临时创建的对象, 通过调用autorelease将其加入到每帧自动释放的内存管理池中,
     在每帧的结束会自动释放
   - 对于集合对象, 应该放到Vector<T>和Map<T>中管理, 这两个容器会在元素加入和释放
     时自动调用retain()和release()
   - 对于生命周期较长的非集合对象, 使用RefPtr<T>管理(autorelease一般用于临时对象),
     这个等价为线程不安全的轻量级shared_ptr<T>
   - RefPtr<T>可以直接加入容器, 已经做好了引用计数的适配
   - 对于UI元素全部使用autorelease管理, 对于游戏内数据全部使用RefPtr
3. UI树及运行时游戏对象
   1. 位置与变换
      位置代表了节点在坐标系中的位置, 而锚点代表了节点的哪个点对应这个位置, 比如
      锚点(0.5, 0.5)就代表节点的中心代表它的位置, 而(0, 0)则代表左下角代表它的
      位置. 旋转, 缩放等操作也和锚点所处的位置有关
   2. 坐标系
      - 左下角为原点, x轴由左至右, y轴由下至上
      - 一个元素的本地坐标系是以左下角为原点, 左下角由锚点和contentSize共同决定
      - convertToNodeSpace用于将一个世界坐标转换到此节点的本地坐标系
      - convertToWorldSpace用于将一个此节点的局部坐标转换为世界坐标
      - convertToXXAR代表以自身的锚点为原点进行世界/本地坐标转换, 这个是不需要
        其他节点参与的
   3. UI树
      - 使用UI树来组织游戏内的显示节点对象
      - 由于是2d渲染, 渲染的顺序决定了最终呈现的效果, UI树采用中序遍历来决定渲染
        顺序, 使用局部z值代表渲染的逻辑顺序, 越大越后渲染
        * 遍历节点的所有局部z值小于0的孩子
        * 处理自身
        * 遍历节点所有局部z值大于等于0的孩子
      - 使用全局z值来排序不同层级之间的元素, 全局z值越高越后渲染, 优先级高于局部
        z值
      - 每个node存储了此节点变换到世界坐标的变换矩阵, 采用脏标记模式进行更新
      - 在ui树之中移动一个节点, 首先要retain放止其在节点树中移除时被释放, 然后
        从父节点之中移除, 然后设置autorelease, 然后再加入到新的节点树之中
4. 框架
   - 应用程序通过实现AppDelegate来完成窗口的管理
     - 打开窗口
     - 设置参数(分辨率, 帧率等)
     - 窗口事件响应(切换窗口)
   - Director类管理着OpenGl窗口, 可以获得当前窗口的分辨率
   - Scene类代表一个UI树的根节点, 代表着一整套渲染场景, 每个时刻最多只有一个
     Scene显示, 通过场景栈来实现在不同的场景之间切换
   - 每一帧的游戏循环做如下工作:
     * 处理用户输入 :: 放在最前边是为了此帧能够立即响应输入而不是滞后
     * 动画计算 :: 动画计算必须要在前边, 因为后边的逻辑有可能修改动画结束之后
       的属性, 如果动画在修改逻辑后面则修改动画就会滞后一帧
     * 物理模拟 :: 碰撞检测等等
     * 自定义逻辑更新 :: 程序的算法和逻辑在此处处理
     * UI树遍历 :: 生成渲染顺序结构和渲染所需参数
     * 绘制 :: 发送到GPU进行渲染
     * 交换缓冲区 :: 将渲染好的页面交换到前台
     * 释放智能指针 :: 释放autorelease对象
5. 游戏更新
   - 帧率: 游戏中每秒钟的绘制次数, 当设置帧数且实际帧数过快时, cocos通过sleep调整
     帧率, 但是如果绘制速度太慢无法达到目标帧率cocos是没有办法解决的
   - scheduler: 需要每一帧更新的对象通过向Scheduler注册来实现每帧的更新
   - 可以通过对Scheduler的timeScale进行设置来修改游戏内的速度
   - 对逻辑注册更新而不是对对象注册更新, 如果注册到每个对象, 对象之间的优先级和更
     新顺序是很难理清的, 一般一个逻辑是一个子系统或者是组件
   - 避免每帧的查找操作, 能缓存尽量缓存, 和UI无关的算法减少其update的调用频率
6. 主线程
   - cocos是一个单线程引擎
   - cocos提供了一个在所有系统和自定义schedule执行之后在主线程调用的方法数组,
     方法为performFunctionInCocosThread
   - 通过注册异步回调, 纹理可以异步加载
   - 异步会导致难以进行单元测试
     
* OpenGL ES2.0 概览
1. GPU是数以千计的更小, 更高效的核心组成, 专门用来处理多任务而设计, 衡量的主要指
   标是每秒钟填充像素
2. OpenGL ES 是 嵌入式系统的图形硬件软件接口
3. 渲染管线
   顶点数组 \rightarrow 顶点着色器 \rightarrow 图元装配 \rightarrow 光栅化 \rightarrow 片段着色器 \rightarrow 片段测试 \rightarrow 帧缓冲
   - 顶点数组 :: 每个顶点定义图元的一个点, 含有顶点坐标, 颜色, 法向量, 纹理坐标
     等数据
   - 顶点着色器 :: 主要执行将本地坐标变换到gl坐标, 并为后边的片段着色器提供一些
     额外输入
   - 图元装配 :: 经过视锥裁剪和视口变换, 将坐标转换为设备坐标(显示器像素为单位)
   - 光栅化 :: 装配过后的2d图元转换为片段, 抗锯齿和多重采样就发生在这个阶段
   - 片段着色器 :: 光照, 阴影, 特效, 纹理都在这个阶段实现
   - 片段测试 :: 深度测试, 模板测试用来筛除部分片段, 通过的片段进入混合阶段
   在这套流程中, 只有两个着色器是可编程的, 其他部分由OpenGL自身控制
4. 并行计算
   OpenGL保证物体的绘制总是按顺序进行的, 但是每个物体的绘制内部是并行的, 主要体现
   在两个方面:
   - 每个阶段内部被拆分成多个子任务
   - 每个顶点和片段都是独立, 并行处理的
5. Cocos2d-x的优化措施
   - 减少渲染次数
   - 分离渲染和逻辑
6. 帧缓冲
   这里存储这每个像素点的所有信息, 包括颜色, 深度, 模板值
   显示设备一般提供两个帧缓冲, 分为前台和后台, 渲染的数据发送的后台, 等到一帧渲染
   完毕后将前后切换, 这样做的目的是给用户一次性呈现一个完整的画面, 而不是支离破碎
   的带有渲染过程的画面

* 全新的绘制系统
1. 新绘制系统特点
   - 绘制逻辑从主逻辑分离
   - 在应用层就进行视口裁剪, 丢弃不会被绘制的元素
   - 采用了自动批处理绘制技术, 合并相邻类似的渲染命令
2. 绘制流程
   1. 遍历ui树, 将绘制命令发送到renderer中
   2. 根据globalz, 对当前渲染队列中的命令排序
      - 渲染队列有三个子队列, 分别为glz<0, glz=0, glz大于0的
      - glz==0的是不需要排序的, 因为默认就是0, 它的顺序就应该是ui树的遍历顺序
      - 这样做的目的是为了减少排序次数, 提高渲染性能
   3. 根据排好序的命令按序渲染
3. RenderCommand
   每次绘制调用的都是一个RenderCommand, 主要有4种类型的RenderCommand:
   - QuadCommand :: 绘制矩形区域
   - BatchCommand :: 绘制ATextureAtlas
   - GroupCommand :: 内部指向一个渲染队列id, 代表一组绘制命令
   - CustomCommand :: 自定义绘制命令
4. Renderer
   一个Renderer持有一个渲染队列栈, 内部存放多个渲染队列, 每当创建一个新的GroupCommand
   时, 会在入栈一个新的渲染队列, 后续的渲染命令都会追加到栈顶, 当GroupCommand结束时
   会自动弹出. 通过绘制栈来实现多个GroupCommand互不干扰, 独立渲染(和函数栈的概念
   类似的)
   渲染队列栈中的每个渲染队列的排序是独立互不干扰的
5. QuadCommand
   - 用于绘制一个或多个矩形区域, 一个quad有四个顶点, 每个顶点有三个数据(位置,
     颜色, 纹理坐标)
   - 自动批绘制的机制如下, 当多个连续的QuadCommand拥有同样的"材料"时, 则不立即
     绘制而是将数据缓存到数组中, 并将这些数据一次性发送到gl中进行绘制, 材料指的是
     纹理, 着色器, 混合模式, gl状态设置
6. 元素的可见性
   - cocosx会在绘制阶段判断Sprite的可见性, 如果不在显示区域内则会跳过, 不发送绘制
     指令到GL
   - Node也有设置可见性的选项, 如果设置为不可见效果和上面是一致的, 但是不可见不代
     表无法响应事件
7. CustomCommand
   由于绘制和ui遍历的分离, 我们无法直到节点什么时候被绘制, 所以我们可以实现一个
   自定义命令, 在绘制阶段触发一个回调来通知绘制开始和结束
7. 
8. 
