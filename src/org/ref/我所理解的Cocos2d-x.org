#+STARTUP: INDENT NUM
#+PROPERTY: header-args:c++ :exports both :results output

* 全新的Cocos2d-x 3.0
1. 采用了C++式的代码命名风格
   - 使用命名空间代替CC前缀
   - 使用C++强枚举类型代表常量
   - 使用了c++11的一些新的语法机制, 比如std::move, override等等
2. 将渲染从ui树之中分离, 可以更灵活的调整渲染顺序, 优化渲染代码
   - 首先遍历ui树, 并依遍历顺序将每个ui的处理作为一个绘制命令发送到渲染栈
   - 优化渲染栈的渲染顺序, 比如合并相同渲染, 批处理渲染, 渲染裁剪等
3. 放弃和cocos2d-iphone进行api同步, 采用独立变化的策略
4. 增加了新的统一消息分发机制
5. 深度整合物理引擎, 无需了解物理引擎的细节就可以方便地使用物理引擎
6. 使用了TTF库重写了字体部分, 支持了更多的字体特效以及功能
7. 提供了大量的可扩展的官方GUI控件

* Cocos2d-x 架构一瞥
1. 架构系统总览
   |                     游戏                     |
   |   动画系统   |  事件系统  |  控件  |  三方工具   |
   |                    渲染系统                  |
   |   核心系统   |  资源  |   音频  |   物理引擎    |
   |      平台独立层       |        |              |
   |      第三方库        |        |              |
   | ios | android | osx | windows | ubuntu     |
2. 内存管理机制
   - 对于临时创建的对象, 通过调用autorelease将其加入到每帧自动释放的内存管理池中,
     在每帧的结束会自动释放
   - 对于集合对象, 应该放到Vector<T>和Map<T>中管理, 这两个容器会在元素加入和释放
     时自动调用retain()和release()
   - 对于生命周期较长的非集合对象, 使用RefPtr<T>管理(autorelease一般用于临时对象),
     这个等价为线程不安全的轻量级shared_ptr<T>
   - RefPtr<T>可以直接加入容器, 已经做好了引用计数的适配
   - 对于UI元素全部使用autorelease管理, 对于游戏内数据全部使用RefPtr
3. UI树及运行时游戏对象
   1. 位置与变换
      位置代表了节点在坐标系中的位置, 而锚点代表了节点的哪个点对应这个位置, 比如
      锚点(0.5, 0.5)就代表节点的中心代表它的位置, 而(0, 0)则代表左下角代表它的
      位置. 旋转, 缩放等操作也和锚点所处的位置有关
   2. 坐标系
      - 左下角为原点, x轴由左至右, y轴由下至上
      - 一个元素的本地坐标系是以左下角为原点, 左下角由锚点和contentSize共同决定
      - convertToNodeSpace用于将一个世界坐标转换到此节点的本地坐标系
      - convertToWorldSpace用于将一个此节点的局部坐标转换为世界坐标
      - convertToXXAR代表以自身的锚点为原点进行世界/本地坐标转换, 这个是不需要
        其他节点参与的
   3. UI树
      - 使用UI树来组织游戏内的显示节点对象
      - 由于是2d渲染, 渲染的顺序决定了最终呈现的效果, UI树采用中序遍历来决定渲染
        顺序, 使用局部z值代表渲染的逻辑顺序, 越大越后渲染
        * 遍历节点的所有局部z值小于0的孩子
        * 处理自身
        * 遍历节点所有局部z值大于等于0的孩子
      - 使用全局z值来排序不同层级之间的元素, 全局z值越高越后渲染, 优先级高于局部
        z值
      - 每个node存储了此节点变换到世界坐标的变换矩阵, 采用脏标记模式进行更新
      - 在ui树之中移动一个节点, 首先要retain放止其在节点树中移除时被释放, 然后
        从父节点之中移除, 然后设置autorelease, 然后再加入到新的节点树之中
4. 框架
   - 应用程序通过实现AppDelegate来完成窗口的管理
     - 打开窗口
     - 设置参数(分辨率, 帧率等)
     - 窗口事件响应(切换窗口)
   - Director类管理着OpenGl窗口, 可以获得当前窗口的分辨率
   - Scene类代表一个UI树的根节点, 代表着一整套渲染场景, 每个时刻最多只有一个
     Scene显示, 通过场景栈来实现在不同的场景之间切换
   - 每一帧的游戏循环做如下工作:
     * 处理用户输入 :: 放在最前边是为了此帧能够立即响应输入而不是滞后
     * 动画计算 :: 动画计算必须要在前边, 因为后边的逻辑有可能修改动画结束之后
       的属性, 如果动画在修改逻辑后面则修改动画就会滞后一帧
     * 物理模拟 :: 碰撞检测等等
     * 自定义逻辑更新 :: 程序的算法和逻辑在此处处理
     * UI树遍历 :: 生成渲染顺序结构和渲染所需参数
     * 绘制 :: 发送到GPU进行渲染
     * 交换缓冲区 :: 将渲染好的页面交换到前台
     * 释放智能指针 :: 释放autorelease对象
5. 游戏更新
   - 帧率: 游戏中每秒钟的绘制次数, 当设置帧数且实际帧数过快时, cocos通过sleep调整
     帧率, 但是如果绘制速度太慢无法达到目标帧率cocos是没有办法解决的
   - scheduler: 需要每一帧更新的对象通过向Scheduler注册来实现每帧的更新
   - 可以通过对Scheduler的timeScale进行设置来修改游戏内的速度
   - 对逻辑注册更新而不是对对象注册更新, 如果注册到每个对象, 对象之间的优先级和更
     新顺序是很难理清的, 一般一个逻辑是一个子系统或者是组件
   - 避免每帧的查找操作, 能缓存尽量缓存, 和UI无关的算法减少其update的调用频率
6. 主线程
   - cocos是一个单线程引擎
   - cocos提供了一个在所有系统和自定义schedule执行之后在主线程调用的方法数组,
     方法为performFunctionInCocosThread
   - 通过注册异步回调, 纹理可以异步加载
   - 异步会导致难以进行单元测试
