#+STARTUP: INDENT NUM
#+PROPERTY: header-args:c++ :exports both :results output

* 全新的Cocos2d-x 3.0
1. 采用了C++式的代码命名风格
   - 使用命名空间代替CC前缀
   - 使用C++强枚举类型代表常量
   - 使用了c++11的一些新的语法机制, 比如std::move, override等等
2. 将渲染从ui树之中分离, 可以更灵活的调整渲染顺序, 优化渲染代码
   - 首先遍历ui树, 并依遍历顺序将每个ui的处理作为一个绘制命令发送到渲染栈
   - 优化渲染栈的渲染顺序, 比如合并相同渲染, 批处理渲染, 渲染裁剪等
3. 放弃和cocos2d-iphone进行api同步, 采用独立变化的策略
4. 增加了新的统一消息分发机制
5. 深度整合物理引擎, 无需了解物理引擎的细节就可以方便地使用物理引擎
6. 使用了TTF库重写了字体部分, 支持了更多的字体特效以及功能
7. 提供了大量的可扩展的官方GUI控件

* Cocos2d-x 架构一瞥
1. 架构系统总览
   |                     游戏                     |
   |   动画系统   |  事件系统  |  控件  |  三方工具   |
   |                    渲染系统                  |
   |   核心系统   |  资源  |   音频  |   物理引擎    |
   |      平台独立层       |        |              |
   |      第三方库        |        |              |
   | ios | android | osx | windows | ubuntu     |
2. 内存管理机制
   - 对于临时创建的对象, 通过调用autorelease将其加入到每帧自动释放的内存管理池中,
     在每帧的结束会自动释放
   - 对于集合对象, 应该放到Vector<T>和Map<T>中管理, 这两个容器会在元素加入和释放
     时自动调用retain()和release()
   - 对于生命周期较长的非集合对象, 使用RefPtr<T>管理(autorelease一般用于临时对象),
     这个等价为线程不安全的轻量级shared_ptr<T>
   - RefPtr<T>可以直接加入容器, 已经做好了引用计数的适配
   - 对于UI元素全部使用autorelease管理, 对于游戏内数据全部使用RefPtr
3. UI树及运行时游戏对象
   1. 位置与变换
      位置代表了节点在坐标系中的位置, 而锚点代表了节点的哪个点对应这个位置, 比如
      锚点(0.5, 0.5)就代表节点的中心代表它的位置, 而(0, 0)则代表左下角代表它的
      位置. 旋转, 缩放等操作也和锚点所处的位置有关
   2. 坐标系
      - 左下角为原点, x轴由左至右, y轴由下至上
      - 一个元素的本地坐标系是以左下角为原点, 左下角由锚点和contentSize共同决定
      - convertToNodeSpace用于将一个世界坐标转换到此节点的本地坐标系
      - convertToWorldSpace用于将一个此节点的局部坐标转换为世界坐标
      - convertToXXAR代表以自身的锚点为原点进行世界/本地坐标转换, 这个是不需要
        其他节点参与的
   3. UI树
      - 使用UI树来组织游戏内的显示节点对象
      - 由于是2d渲染, 渲染的顺序决定了最终呈现的效果, UI树采用中序遍历来决定渲染
        顺序, 使用局部z值代表渲染的逻辑顺序, 越大越后渲染
        * 遍历节点的所有局部z值小于0的孩子
        * 处理自身
        * 遍历节点所有局部z值大于等于0的孩子
      - 使用全局z值来排序不同层级之间的元素, 全局z值越高越后渲染, 优先级高于局部
        z值
      - 每个node存储了此节点变换到世界坐标的变换矩阵, 采用脏标记模式进行更新
      - 在ui树之中移动一个节点, 首先要retain放止其在节点树中移除时被释放, 然后
        从父节点之中移除, 然后设置autorelease, 然后再加入到新的节点树之中
4. 框架
   - 应用程序通过实现AppDelegate来完成窗口的管理
     - 打开窗口
     - 设置参数(分辨率, 帧率等)
     - 窗口事件响应(切换窗口)
   - Director类管理着OpenGl窗口, 可以获得当前窗口的分辨率
   - Scene类代表一个UI树的根节点, 代表着一整套渲染场景, 每个时刻最多只有一个
     Scene显示, 通过场景栈来实现在不同的场景之间切换
   - 每一帧的游戏循环做如下工作:
     * 处理用户输入 :: 放在最前边是为了此帧能够立即响应输入而不是滞后
     * 动画计算 :: 动画计算必须要在前边, 因为后边的逻辑有可能修改动画结束之后
       的属性, 如果动画在修改逻辑后面则修改动画就会滞后一帧
     * 物理模拟 :: 碰撞检测等等
     * 自定义逻辑更新 :: 程序的算法和逻辑在此处处理
     * UI树遍历 :: 生成渲染顺序结构和渲染所需参数
     * 绘制 :: 发送到GPU进行渲染
     * 交换缓冲区 :: 将渲染好的页面交换到前台
     * 释放智能指针 :: 释放autorelease对象
5. 游戏更新
   - 帧率: 游戏中每秒钟的绘制次数, 当设置帧数且实际帧数过快时, cocos通过sleep调整
     帧率, 但是如果绘制速度太慢无法达到目标帧率cocos是没有办法解决的
   - scheduler: 需要每一帧更新的对象通过向Scheduler注册来实现每帧的更新
   - 可以通过对Scheduler的timeScale进行设置来修改游戏内的速度
   - 对逻辑注册更新而不是对对象注册更新, 如果注册到每个对象, 对象之间的优先级和更
     新顺序是很难理清的, 一般一个逻辑是一个子系统或者是组件
   - 避免每帧的查找操作, 能缓存尽量缓存, 和UI无关的算法减少其update的调用频率
6. 主线程
   - cocos是一个单线程引擎
   - cocos提供了一个在所有系统和自定义schedule执行之后在主线程调用的方法数组,
     方法为performFunctionInCocosThread
   - 通过注册异步回调, 纹理可以异步加载
   - 异步会导致难以进行单元测试
     
* OpenGL ES2.0 概览
1. GPU是数以千计的更小, 更高效的核心组成, 专门用来处理多任务而设计, 衡量的主要指
   标是每秒钟填充像素
2. OpenGL ES 是 嵌入式系统的图形硬件软件接口
3. 渲染管线
   顶点数组 \rightarrow 顶点着色器 \rightarrow 图元装配 \rightarrow 光栅化 \rightarrow 片段着色器 \rightarrow 片段测试 \rightarrow 帧缓冲
   - 顶点数组 :: 每个顶点定义图元的一个点, 含有顶点坐标, 颜色, 法向量, 纹理坐标
     等数据
   - 顶点着色器 :: 主要执行将本地坐标变换到gl坐标, 并为后边的片段着色器提供一些
     额外输入
   - 图元装配 :: 经过视锥裁剪和视口变换, 将坐标转换为设备坐标(显示器像素为单位)
   - 光栅化 :: 装配过后的2d图元转换为片段, 抗锯齿和多重采样就发生在这个阶段
   - 片段着色器 :: 光照, 阴影, 特效, 纹理都在这个阶段实现
   - 片段测试 :: 深度测试, 模板测试用来筛除部分片段, 通过的片段进入混合阶段
   在这套流程中, 只有两个着色器是可编程的, 其他部分由OpenGL自身控制
4. 并行计算
   OpenGL保证物体的绘制总是按顺序进行的, 但是每个物体的绘制内部是并行的, 主要体现
   在两个方面:
   - 每个阶段内部被拆分成多个子任务
   - 每个顶点和片段都是独立, 并行处理的
5. Cocos2d-x的优化措施
   - 减少渲染次数
   - 分离渲染和逻辑
6. 帧缓冲
   这里存储这每个像素点的所有信息, 包括颜色, 深度, 模板值
   显示设备一般提供两个帧缓冲, 分为前台和后台, 渲染的数据发送的后台, 等到一帧渲染
   完毕后将前后切换, 这样做的目的是给用户一次性呈现一个完整的画面, 而不是支离破碎
   的带有渲染过程的画面

* 全新的绘制系统
1. 新绘制系统特点
   - 绘制逻辑从主逻辑分离
   - 在应用层就进行视口裁剪, 丢弃不会被绘制的元素
   - 采用了自动批处理绘制技术, 合并相邻类似的渲染命令
2. 绘制流程
   1. 遍历ui树, 将绘制命令发送到renderer中
   2. 根据globalz, 对当前渲染队列中的命令排序
      - 渲染队列有三个子队列, 分别为glz<0, glz=0, glz大于0的
      - glz==0的是不需要排序的, 因为默认就是0, 它的顺序就应该是ui树的遍历顺序
      - 这样做的目的是为了减少排序次数, 提高渲染性能
   3. 根据排好序的命令按序渲染
3. RenderCommand
   每次绘制调用的都是一个RenderCommand, 主要有4种类型的RenderCommand:
   - QuadCommand :: 绘制矩形区域
   - BatchCommand :: 绘制ATextureAtlas
   - GroupCommand :: 内部指向一个渲染队列id, 代表一组绘制命令
   - CustomCommand :: 自定义绘制命令
4. Renderer
   一个Renderer持有一个渲染队列栈, 内部存放多个渲染队列, 每当创建一个新的GroupCommand
   时, 会在入栈一个新的渲染队列, 后续的渲染命令都会追加到栈顶, 当GroupCommand结束时
   会自动弹出. 通过绘制栈来实现多个GroupCommand互不干扰, 独立渲染(和函数栈的概念
   类似的)
   渲染队列栈中的每个渲染队列的排序是独立互不干扰的
5. QuadCommand
   - 用于绘制一个或多个矩形区域, 一个quad有四个顶点, 每个顶点有三个数据(位置,
     颜色, 纹理坐标)
   - 自动批绘制的机制如下, 当多个连续的QuadCommand拥有同样的"材料"时, 则不立即
     绘制而是将数据缓存到数组中, 并将这些数据一次性发送到gl中进行绘制, 材料指的是
     纹理, 着色器, 混合模式, gl状态设置
6. 元素的可见性
   - cocosx会在绘制阶段判断Sprite的可见性, 如果不在显示区域内则会跳过, 不发送绘制
     指令到GL
   - Node也有设置可见性的选项, 如果设置为不可见效果和上面是一致的, 但是不可见不代
     表无法响应事件
7. CustomCommand
   由于绘制和ui遍历的分离, 我们无法直到节点什么时候被绘制, 所以我们可以实现一个
   自定义命令, 在绘制阶段触发一个回调来通知绘制开始和结束

* 纹理
1. 光栅化
   将2d图元转化为帧缓冲中整数坐标上的片段的过程叫做光栅化
   * 多重采样 :: 由于屏幕是由离散的像素点构成的, 所以在对图元采样的时候会丢失一些
     信息导致边缘出现锯齿, 采用多重采样(以目标为中心采集多个点的颜色值来设置此点
     最终颜色值)可以有效柔化边缘
   * 纹理坐标
     纹理坐标通常使用(u, v)来表示, 分别代表纹理的宽度和高度, 片段着色器中使用的
     片段纹理坐标通常使用(s, t)坐标, 范围为[0, 1], 由(u, v)\rightarrow(s, t)这一规范化
     过程是在光栅化阶段完成的
2. 像素矩形
   表示一个矩形区域的二维像素数组, 存储颜色值的像素矩形被称为纹理
   一个纹理通过解包操作, 将数值传输到gl之中形成rgba数值
3. 客户端图像格式
   客户端在传输纹理的时候必须先解压图像资源, 转换为GL服务端支持的纹理格式, 才能确
   保纹理正确使用, 一般有RGBA8888, RGBA4444, 后面的数字一般代表每个分量所占用的
   位数
4. 纹理对象和加载纹理
   通过命令将纹理加载到GL之后, 纹理会一直占用内存, 不用的时候可以使用glDeleteTextures
   删除纹理, 由于应用程序不直接持有纹理的指针, 所以应用程序需要使用glBindTexture
   来设定当前使用的纹理
5. OpenGl ES支持在一个渲染管线中使用多个纹理, 用来增强画面表现力
6. 纹理在放缩时会出现画面失真的情况, 有两种放缩策略:
   - GL_NEAREST :: 选择最近的纹素采样, 性能高, 表现差
   - GL_LINEAR :: 选择2x2的区域进行双线性插值得到一个新的颜色, 性能稍差, 表现平滑
7. 多级纹理
   一种预先生成多个不同分辨率下纹理的技术, 不需要渲染时临时计算而是在处理资源阶段
   就生成多级纹理, 有效提高渲染性能, 其中每一级的纹理大小是上一级的1/2
   - 和普通的放缩一样, 多级纹理有四种缩放策略, cocos默认使用GL_LINEAR_MIPMAP_NEAREST,
     这是在性能和效果上比较平衡的一种缩放策略
   - 使用Texture2D::initWithMipmaps上传多级纹理
   - 使用glGenerateMipMap来生成多级纹理, cocos要求生成多级纹理的原始纹理尺寸一定
     是2的指数倍
8. 纹理压缩采用了和传统的压缩截然不同的策略(由于使用场景和侧重点不一致), 如下所示:
   - 解压缩度快
   - 压缩速度慢
   - 随机读取快
   - 采用固定压缩率, 有损压缩
   常用的两种压缩格式:
   - PVRTC :: 支持RGBA通道, 支持alpha预乘
   - ETC :: 不支持alpha通道, 通过其他解决方案来存放透明度信息
9. 纹理管理
   - 纹理在没删除之前, 一直会驻留在GPU中
   - 使用TextureCache管理文理的创建, 缓存, 和删除
   - 场景过度时采用引用计数管理纹理, 不是物理上的引用计数, 而是逻辑上的引用计数,
     如果某个场景使用某个纹理(不管他在这个场景使用了多少次), 则逻辑计数+1, 如果
     下个场景不用则减一, 为0时则释放纹理. 采用这种方式可以有效处理场景过度时纹理
     的管理问题
   - 即便是动态生成纹理的场景, 纹理也最好进行预加载(而不是等到真正使用的时候才加
     载)
10. 纹理大小的计算
    size = width * height *bpp/8
    其中width和height是宽和高, 单位为像素, bpp为每个像素所占用的位数, RGBA8888
    就占用32位, 所以一个1024*1024, 采用RGBA8888格式的纹理的大小为1024*1024*4
    =4M
    如果使用了多级纹理, 则还要乘以1.33
11. 最佳实践
    - 硬件 :: 硬件厂商会针对自己的硬件产品做出优化
    - 程序 ::
      1. 预加载
      2. 及时释放不再使用的纹理
      3. 多个细碎纹理合成一个大纹理
      4. 使用多级纹理减少内存占用
      5. 使用多重纹理取代多次绘制
      6. 使用alpha预乘减少混合计算量
    - 资源 ::
      1. 选择合适的资源格式, 对于一些不透明的背景来说, 采用RGB565, 既能获得极高的
         颜色表现, 内存占用还低
      2. 使用压缩纹理, 由于游戏场景是由很多复杂的元素构成的, 一个图片的压缩损失实
         际影响不大

* 精灵
精灵是2d游戏中最重要的元素, 他将一个纹理的部分(或者全部)矩形区域绘制到屏幕上
1. 精灵在cocos内使用quadcommand绘制
2. 精灵的颜色混合
   将光栅化产生的颜色称为source, 帧缓冲里的颜色称为destination, 根据不同的混合模
   式有不同的混合公式, 拿默认的FUNC_ADD公式举例:
   R=R_{s}*S_{r} + R_{d}*D_{r}
   G,B和A和R同理, 其中S和D分别代表source和dest的权重系数, cocos默认的系数如下所示:
   - source (GL_SRC_ALPHA) :: 四个系数为S_{A} (S_{A}为alpha值除以255, 是0-1的小数)
   - destination (GL_ONE_MINUS_SRC_ALPHA) :: 四个系数为1-S_{A}_{}
3. 精灵的颜色叠加
   如果设置了cascade模式, 则子sprite的颜色会受到父节点颜色的影响, 叠加公式为:
   #+BEGIN_QUOTE
   displaycolor.r = selfcolor.r * parentcolor.r/255.0 
   #+END_QUOTE
   g和b分量同理, 举例就是如果父节点是红色, 那么叠加之后子节点无论之前是什么颜色,
   最后显示的颜色一定g和b分量都为0(因为父节点这两个分量为0), r分量和自己的颜色
   一致(因为父节点的颜色255/255 == 1)
4. alpha预乘
   已知颜色混合的默认公式为(R_{s}, G_{s}, B_{s})*A_{s} + (R_{d}, G_{d}, B_{d})*(1-AS)
   通过提前计算RGB通道实际的值(R_{s}, G_{s}, B_{s})*A_{s}, 减少渲染时的计算次数
5. 精灵表
   通过将多个精灵合到一张纹理上, 并通过配置文件(xml, json, plist)来定位每个精灵
   的信息. 这项计数可以有效减少绘制次数, 显著地提高性能
6. 精灵动画
   - 关键帧动画
   - 骨骼动画
   这两种动画一般都通过一个或多个精灵表存储精灵, 通过配置文件存储关键帧信息, 骨骼
   信息
7. 批绘制的使用场景
   1. 模型简单, 元素都来自同一个纹理
   2. 位于同一相邻层级
   Label, TileMap, Particle System非常符合这些特征, 此时应该使用SpriteBatchNode
   来绘制, 其他情况应该采用Sprite的自动批绘制
8. 九宫格
   有些时候对纹理缩放, 我们只想缩放中间的某个区域(边缘不变), 由于一般中间区域都是
   纯色区域, 缩放是不会导致失真的. 通过九宫格把纹理划分为9个区域, 只有最中间的区域
   会受到放缩影响, 其他8个角落不会变化.

* OpenGL ES着色语言
1. 基础类型
   * void
   * bool
   * int
   * float
   * vec
   * mat
   * sampler
   * struct, struct不能嵌套
   * array
2. 存储限定符
   * none :: 局部可读写变量或者方法参数
   * const :: 编译时常量
   * attribute :: 应用程序传递给顶点着色器的顶点数据
   * uniform :: 应用程序传递给顶点和片段着色器的全局变量, 在一个图元的绘制过程中保持不变
   * varying :: 由顶点着色器传递给片段着色器, 经过插值的易变变量
3. 构造器
   着色器语言支持转型, 例如使用int(bool)将一个bool值转为int, 有如下需要注意的点:
   * 单个标量构造矢量会使矢量的所有值为标量的值
   * 可以使用多个标量构造矢量
   * 标量构造矢量时如果类型不对会自动转换
   * 可以使用单个标量来初始化矩阵的对角线
   * 可以使用多个矢量或标量构造矩阵
   * 结构体也可以使用构造器, 但是不支持类型转换
4. 矢量的分量
   常用的三种形式为:
   | (x, y, z, w) | 顶点坐标 |
   | (r, g, b, a) | 颜色分量 |
   | {s, t, p, q) | 纹理坐标 |
   * 分量可以随意组合, 但是不能超过自身分量的上限, 比如:
   #+begin_src c
     vec4 v4;
     v4.rgba;   // 等与自身
     v4.rrrr;   // 一个vec4变量
     v4.rgb;    // 一个vec3变量
     v4.b;      // 一个float变量
     v4.xtq;    // 不合法, 必须使用相同的形式
     v4.xxyyzz; // 不合法, 太长了
   #+end_src
   * 分量可以作为左值, 此时不能重名
   * 可以使用下标索引分量, 0代表x, 1代表y, 以此类推
5. 矩阵的分量
   矩阵的下标代表矩阵的一列, 下标的个数等于矩阵的列数
6. 结构体和成员
   * 成员使用.引用
   * 相同类型的结构体之间可以比较, 当且仅当它们的每个成员都相等时, 它们相等
7. 矢量和矩阵操作
   * 矢量和标量操作将会把标量作用到矢量的每一个分量上
   * 其余情况一般遵循线性代数的计算方式
   
* OpenGL ES着色程序
1. 顶点和顶点数组
   * 图元由一系列顶点构成, 共有7种图元
   * 以STRIP结尾的图元可以共享部分顶点
   * 顶点由属性构成, 比如坐标, 颜色, 纹理坐标等
   * 通过VertexAttribPointer定义顶点数组
   * 通过BindAttribLocation绑定顶点数组绑定到着色器中的变量
   * 通过DrawArrays和DrawElements将顶点数组传送到GPU
     - DrawArrays按照顺序绘制图元
     - DrawElements根据传入的索引来组合图元, 方便重用顶点
2. 顶点缓冲对象
   通过VBO将部分常用到顶点数据缓存到高速的GPU缓存中
   - 使用GenBuffers分配缓冲
   - 使用BindBuffer创建缓冲
   - 使用BufferData向缓冲传送数据
   - 使用VAO来存储多个VBO对象, 记录其对顶点数组的状态的修改
3. 着色器程序
   - 着色器对象需要加载, 编译, 连接之后才能使用, 链接之后叫做着色器程序
   - 如果没有设置着色器程序, 那么渲染管线是无法工作的
   - 一个着色器对象被删除时, 如果它链接的着色器程序正在使用, 则不会被删除, 等到所
     有使用此对象的着色器程序都不使用时释放此对象
   - 一个着色器对象可以被附加到多个着色器程序上, 一个着色器程序只能有一个顶点着色
     对象和一个片段着色对象
   - 一个着色器程序被删除时, 如果它正在被使用, 那么它不会被删除, 只有它不再被使用
     的时候才会被删除
4. 顶点着色器
   - 顶点着色器接受两种输入参数:
     * 顶点属性变量
     * 全局属性变量
   - 顶点着色器输出一个变换过后的坐标值, 以及颜色和纹理坐标
5. 片段着色器
   图形的效果大部分在此处实现, 比如法线贴图, 颜色融合等等
   - 片段着色器的输入参数:
     * 顶点着色器的输出
     * 全局变量
     * 纹理采样器
   - 片段着色器的输出参数:
     * 片段颜色值
6. 最佳实践
   - 创建一个着色器并链接是很耗时的, 应该在初始化的时候创建并缓存
   - 如果一个变量对一次绘制来说是始终相同的, 那么应该设置为全局属性
   - 着色器中尽量使用常量来索引数组, 效率比变量要高很多
   - 尽可能多的使用多重纹理, 可以有效提高性能和渲染效果
