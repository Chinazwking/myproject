
# Table of Contents

1.  [整洁代码](#orgaee90cb)
2.  [有意义的命名](#org694fa12)
3.  [函数](#org68e8bd7)
4.  [注释](#org128f81d)
5.  [格式](#org21aa9ce)
6.  [对象和数据结构](#orgef02992)
7.  [错误处理](#org2fb7c65)
8.  [边界](#org81645ae)
9.  [单元测试](#org011d7e5)
10. [类](#orgfc9c923)



<a id="orgaee90cb"></a>

# 整洁代码

1.  代码永远不会消失, 因为代码代表着对需求最精确的约束
2.  不要因为进度或是经理的要求而放松对代码质量的把控
3.  为了赶时间而让代码混乱只会让你永远赶不上时间
4.  整洁的代码有以下特征:
    -   只做一件事
    -   短小精悍
    -   命名规范易读
    -   实体尽量少, 依赖尽量少
    -   能够通过测试
    -   没有重复代码
5.  阅读代码的时间要远远大于修改代码的时间, 所以让代码易读可以有效提高工作效率
6.  随时保持代码整洁, 改完后保证代码比改之前更干净


<a id="org694fa12"></a>

# 有意义的命名

1.  名副其实, 命名要清楚的表现它的作用, 如果还需要注释证明还不够名副其实
2.  避免误导, 不要用一些带有歧义的命名, 比如l和O很容易被看成1和0
3.  做有意义的区分, Variable永远不应该出现在变量中, NameString当然是String
4.  使用读的出来的名字, 不要用一些奇奇怪怪的缩写和自造词
5.  使用可搜索的名称, 不要使用魔法数字, 单字母的命名应该仅存在于短的局部函数中,
    名称长短应与其作用域成正比
6.  避免使用编码, 不必使用匈牙利命名法, 不要使用m<sub>代表私有</sub>, 不要使用I,C来标记类
7.  避免思维映射, 明确是王道, 不要指望别人看到一个特殊的名字能够产生和你一样的理解
8.  类名应当是名词或名词性短语, 不应当是动词
9.  方法应该是动词或者动词短语
10. 不要起一些特殊的名称, 比如俚语和文化密切关联的名称
11. 每个概念对应一个词, 比如读取属性都用get, 设置都用set
12. 别用双关语, 比如add仅代表两个对象相加, 如果向一个集合中加入一个对象应该使用
    append, 而不是add
13. 只有程序员才会读你的代码, 所以尽管使用计算机科学的术语来命名吧
14. 如果无法采用计算机科学术语命名, 那么就采用涉及问题领域的名称, 这样至少可以
    请教此领域的专家名称的含义
15. 添加有意义的语境, 任何变量都不可能自解释, 他至少需要一个上下文来表明的他的作
    用, 可以将一些变量放到一个命名良好的类或者命名空间中, 这样可以明确表明变量的
    作用
16. 不要添加没有意义的语境, 只要短名称足够清晰, 短的一定要比长的要好, 比如说一个
    类叫做GSD, 那他的方法以GSD开头显然就不是一个好做法, 因为这个GSD和当前语境
    毫无关系
17. 碰到可以改的名字尽量优化, 不要让不好的名字阻碍你前进的步伐


<a id="org68e8bd7"></a>

# 函数

1.  短小: 函数最长20行, 每行不超过150个字符. if else while等结构中应该只有一行语句
    并且应该是一句函数调用, 这样可以使整个结构更加清晰
2.  只做一件事: 函数应该做一件事. 做好这件事. 只做这一件事
    -   一个函数内部的所有逻辑应该都唯一同一抽象层次
    -   判断一个函数是否只做了一件事, 可以看看是否能够拆出一个新的函数, 并且该函数不
        是仅仅重新诠释
3.  每个函数一个抽象层级: 所有的函数都要位于同一抽象层级上, 最好函数的阅读要符合
    TO原则, 即每一段函数的内部都是他下一个抽象层级的函数, 这样阅读代码就可以自顶向
    下逐步阅读
4.  对于switch, 最好只用一次, 用于工厂函数的分发多态, 并且隐藏在细节中其他部分看不
    到. 当然有时候可能也要违反这个规则
5.  长而具有描述性的名称, 远远比短而令人费解的名称要好, 当然短而明确最好
6.  函数参数: 最好没参数, 其次是一个和两个参数, 最好避免三个及以上参数. 输出参数远
    比输入参数要难以理解
    -   单参数要么是代表根据传入的内容返回一个内容, 要么代表根据传入的参数修改状态
    -   绝对不要向参数传入标识参数(bool), 应该拆为两个参数
    -   尽量将二元函数转换为一元函数
    -   如果函数有三个及以上的参数, 说明其中一些的参数应该封装成一个类, 他们应该是同
        属于一个更高概念的一部分
    -   给函数取个好名字能够更方便的了解函数的意图
7.  无副作用: 如果函数存在副作用, 那么在命名时一定要体现出来, 如果函数有输出参数,
    应将其转为对所属对象的修改
8.  分隔指令和询问: 一个函数要么回答某个问题, 要么做一件事, 不要既回答问题又做事
9.  带有错误码的函数实际上违反了上一条原则, 所以应该使用异常来代替错误码
    -   将异常捕捉和业务逻辑分离:
    -   存在异常处理的函数第一句应该就是try, 并且整个函数只做异常处理这一件事
        
            try:
                dosomething()
            except:
                pass
            
            def dosomething():
                pass
10. 不要有重复代码, 当出现的时候将重复的代码应该抽离作为一个新的模块, 重复就是
    软件工程的万恶之源
11. 如果函数结构很长, 那么最好遵循结构化原则, 即每个函数内部只能有一个return,
    循环中不要有break, continue. 永远不要用goto, 但对于小函数不需要遵循这些规则
12. **永远不要一开始就打算写出完美的函数**, 而是应该先写出能够实现功能的函数, 然后
    再测试用例的辅助下, 在维护函数功能稳定的同时, 消除冗余, 修改名称, 拆分函数,
    重新安置方法位置, 最后重新组装

编程艺术是且一直是语言设计的艺术, 永远不要忘记我们真正的目标在于讲述系统的故事,
而我们编写的函数干净利落的拼装到一起, 帮我们描述这个故事


<a id="org128f81d"></a>

# 注释

什么也比不上放置良好的注释来的有用, 什么也不会比陈旧, 提供错误新的的注释更有破坏
性. 注释总是一种失败, 当你能用代码表明你的想法是, 永远不要添加注释. 因为注释会撒
谎, 而代码不会.

1.  注释不能美化糟糕的代码: 与其花时间为糟糕的代码添加注释, 不如将花时间清洁那些代
    码, 把代码弄干净
2.  用代码来阐述, 与其使用注释, 不如使用命名得当的函数来描述你的功能
3.  好注释
    -   法律信息
    -   提供信息的注释: 比如返回值, 函数说明
    -   对意图的注释: 解释这样做的原因(不是你实现的具体逻辑)
    -   阐释: 当将某些晦涩难明的参数和返回值翻译为某种可读的形式
    -   警示: 警告其他程序员某个操作的代价和后果
    -   TODO: 有时因为某些原因将某些该做但是没法做的任务作为注释留在代码中, 提示其他
        人需要做某事. 但是要注意如果TODO过期应该及时删除
    -   放大: 当某个代码看起来不太合理, 这个时候需要注释来诠释反常规的原因
    -   公共API: 这种代码一般需要提供注释
4.  坏注释
    -   喃喃自语: 不要写别人看不懂的注释
    -   多余的注释: 不要重复和代码一样的注释, 这样的二手信息毫无意义
    -   误导性注释: 如果注释是错的, 依赖这个注释编程的程序员可能会陷入灾难
    -   循规式注释: 所谓的每个函数都要有注释的规矩是愚蠢可笑的, 只会把你的代码搞乱
    -   日志式注释: 存在版本控制系统之后这种日志式可以全部删除掉了
    -   废话注释: 不要写没有意义的废话作为注释
    -   能用函数和变量名解释清楚就不要用注释
    -   不要加位置标记, 也不要在各种闭合的结构后面加注释表明闭合结束
    -   不要加归属信息, 这种信息应当保存在版本控制系统里面
    -   代码不用不要注释, 直接删除会更好
    -   不要加HTML注释, 使用工具将翻译出html注释
    -   注释一定要和它所注释的内容在一起, 它所描述的内容一定是附近能看到的
    -   信息不要太多, 简明扼要即可
    -   注释本身就是用来解释不能自解释的代码的, 如果注释本身还需要解释, 那这个注释就
        是不合理的
    -   短函数不需要注释, 起个好名字更加重要


<a id="org21aa9ce"></a>

# 格式

1.  格式比实现功能的代码本身还要重要, 随着无数的版本更迭, 你的代码早已可能消失不见,
    但是格式会一直影响着
2.  垂直格式
    -   源代码文件行数应该尽可能控制在500行内, 总的来说越短越容易理解
    -   源代码的名称应该简单而一目了然, 第一段是大纲阐述高层次概念, 细节逐步展开
    -   使用空行来区分独立的逻辑区段
    -   关联的逻辑行应该靠在一起, 不要用空行分开
    -   关系密切的概念应该相互靠近, 不应该放到不同的文件之中
        -   变量的声明应该尽可能靠近其使用的位置
        -   实体变量应该在固定的位置声明(顶部或者底部)
        -   如果一个函数调用了另一个函数, 那么应该把它们放到一起, 调用者在上
        -   如果一组代码概念相关, 比如说都用来测试某个东西, 虽然他们测试的是不同的角度,
            它们也应该放到一起, 因为它们有极强的概念相关性, 这时候互相调用是第二位的
3.  水平格式
    -   尽可能保持短小, 最多不要超过120
    -   使用空格分隔相关性较弱的概念, 也可以用来强调运算符的优先级
    -   不要使用水平对齐, 这是在强调其实不重要的东西
    -   严格遵循缩进规则, 即便是单行的if, while也要使用缩进结构
    -   循环或者判断中内容为空也要保持缩进
    -   如果团队订下了编码规范, 那么一定要遵循它. 一个好的软件系统是由一系列风格类似
        的文件构成的


<a id="orgef02992"></a>

# 对象和数据结构

1.  数据抽象
    使用赋值器和取值器并非在变量上放置一个函数层那么简单, 它隐藏了实现, 关乎抽象
    
        class Point(object):
            def __init__(self, x, y):
                self.x = x
                self.y = y
        
        class AbstractPoint(object):
            def getX():
                pass
            def getY():
                pass
            def setCartesian(x, y):
                pass
            def SetPolar(r, theta):
                pass
    
    第二个代码中你无法确定坐标系到底是极坐标还是笛卡尔坐标, 但是它提供了一套存取
    结构, 隐藏了具体实现而暴露接口, 这个就是抽象
2.  数据和对象的反对称性
    过程式代码和面向对象具有反对称性, 过程式代码添加新的类型需要修改所有函数, 但
    添加函数不需要修改类型. 而面向对象通过多态可以灵活的添加新的类型而不需要修改
    已存在的类型, 但是添加新的函数需要修改所有的类
    
        # 面向过程
        class Circle(object):
            def __init__(self, radius):
                self.radius = radius
        
        class Rectangle(object):
            def __init__(self, height, width):
                self.w = width
                self.h = height
        
        class Geometry(object):
            def area(obj):
                if isinstance(obj, Circle):
                    return obj.radius**2 * 3.14
                if isinstance(obj, Rectangle):
                    return obj.w * obj.h
        
        # 面向对象
        class Shape(object):
            def area():
                pass
        
        class Circle(Shape):
            def area():
                pass
        
        class Rectangle(Shape):
            def area():
                pass
    
    对于所有面向对象很困难的事情, 对于面向对象都是很简单的, 反之亦然, 这是它们反对
    称性的体现. 所以一切都是对象只是个传说, 有些时候你可能真的需要在一些简单地结构
    上做一些过程式的操作
3.  得墨忒耳律
    -   类C的方法f只应该调用以下对象的方法:
        
        -   C
        -   由f创建的对象
        -   作为参数传递给f的对象
        -   由C的实体变量持有的对象(成员)
        
        即只跟朋友谈话, 不跟陌生人谈话. 换言之, 方法不应该调用由任何函数返回的对象的
        方法
    -   不要写火车代码, 比如a.b().c().d(), 如果b, c, d都是方法, 这种写法明显违反
        了定律, 如果不是方法而是数据结构, 没有任何行为, 自然就会暴露内部结构, 这样就
        不违反定律, 为了避免这种情况, 可以让a.d()封装好b().c().d()的行为, 这样就不
        会违反定律
    -   不要混淆数据结构和对象, 一个类型要么是数据结构(没有任何行为), 要么是对象(封装)
        有公开的数据对象却有公共改值器, 诱导外部以过程式的方法使用这个类型, 这明显是
        没有想清楚这个类型是否需要函数的保护
4.  数据传输对象
    最为精炼的数据结构是只有公共变量没有函数的类, 这种类型一般用于数据传输中
    有两种变形结构:
    -   bean式: 以对象的形式包装这个数据结构, 提供读取/存取器, 实际上没什么作用
    -   active record: 在bean式的基础上提供了浏览的方法, 注意, 千万不要在这里面加入
        和业务逻辑相关的函数, 这导致了数据结构和对象的混合


<a id="org2fb7c65"></a>

# 错误处理

1.  使用异常而不是返回码
2.  编写可能抛出异常的代码时, 先写try-except-finally语句, 通过TDD来缩小try的
    范围和提高except的准确度
3.  抛出异常时应该给出异常发生的详细原因
4.  在需要时定义异常包装类, 所谓的异常包装类时指对一个可能抛出异常的行为进行包装,
    无论它内部会抛出多少种异常都在内部处理, 并抛出自定义的异常
    
        class MyException(Exception):
            pass
        
        class ExceptionWrapper(object):
            def open(): # 封装之后可以随意替换内部实现而不用担心影响外部
                try:
                    # some operation
                    pass
                except TypeError as e:
                    raise MyException(e)
                except RuntimeError as e:
                    raise MyException(e)
        
        sth = ExceptionWrapper()
        try:
            sth.open()
        except MyException as e:  # 可以有效减少异常处理的代码
            # some handle
5.  定义常规流程, 有些时候可以将异常的情况封装为一个特殊类来处理特例, 这样客户代码
    就不需要处理异常行为了
6.  返回值不要为None, 应该抛出异常或者创建一个特例对象来处理(比如+None本来抛出异常
    , 但可以用+0来代替, 近似这个意思)
7.  函数传参更不要传入None
8.  将错误处理代码隔离于主逻辑之外, 就能得到简洁且健壮的代码


<a id="org81645ae"></a>

# 边界

1.  使用第三方代码时, 可以用自己的类将第三方代码的使用细节隐藏, 分隔边界以方便灵活
    修改第三方库
2.  学习型测试指的是对第三方包编写测试代码来逐步进行功能测试(不是生产环境), 在测试
    的过程中学习第三方包的功能, 使用学习性测试可以确保第三方程序包按照我们想要的方
    式工作
3.  对于还不存在的代码, 可以先根据客户代码的需求定义一个接口, 并依据这个接口进行
    编码, 当不存在的代码功能实现的时候, 可以通过一个adapter将此段代码转换为定义的
    接口的形式, 并将和这段代码的交互功能全部封装到adapter中
4.  无论是使用类包装第三方代码限制功能还是使用适配器, 都会使两个实体的交互更加整洁
    两边进行自由变化的时候只需要修改中间层即可


<a id="org011d7e5"></a>

# 单元测试

1.  TDD三定律:
    -   在编写不能通过的单元测试前, 不可编写生产代码
    -   只编写刚好无法通过的单元测试, 不能编译也算不通过
    -   只编写刚好足以通过当前失败测试的生产代码
2.  正是单元测试使得我们的代码可维护, 可开发, 可修改. 无论架构有多好, 如果没有测试
    , 每次改变都有可能带来未知的bug. 正因为如此, 保持测试代码的整洁性和可读性是非
    常重要的
    
    -   每个测试用例要符合(BUILD-OPERATE-CHECK)模式, 即先构造, 然后操作, 然后测试
        操作结果是否正确
    -   测试环境和生产环境是不同的, 有些在生产环境无法的操作可以在测试环境下操作
    -   每个测试用例的断言要尽可能少, 每个测试用例只测试一个概念
    
        def testSth():
            obj = makeSth()
            obj.doSmt()
            assert obj.isOk() is True
3.  F.I.R.S.T原则
    -   测试应该是快速的(fast), 如果速度慢, 测试就不频繁, 就没法快速发现问题
    -   每个测试之间应该是相互独立的(independent), 相互之间不应该干扰
    -   可重复的(repeatable), 测试应该可以在任何环境下重复并且结果一直
    -   自足验证(self-validating),测试应该有bool输出, 通过看结果直接判断是否通过了测
        试, 而不是查看日志或者是手工对比
    -   及时(timely), 测试要及时编写


<a id="orgfc9c923"></a>

# 类

1.  如果能的话, 优先保证类的封装
2.  类应该短小, 不是以代码行数衡量类的大小, 而是以类的权责来衡量, 每个类应该只有
    一个权责, 有一个衡量的方法, 就是它的功能可以在25个单词之内描述出来, 并且没有
    并且, 但, 如果, 与等单词, 也没有管理器, 处理器这种单词
    -   单一职权原则, 类或模块应该只有一个修改的理由, 这个原则是OO中最重要的原则,
        所以在实际工作中可以先让代码工作, 但正确工作会后一定要合理拆分为多个不同的类
        确保单一职权
    -   内聚, 类应该只有少量实体变量, 每个变量应该为所有方法所使用的, 这种情况叫做
        高内聚(当然实际实践中很难做到这样的内聚), 所以编写类应该让类的内聚程度较高
    -   为了保持较高的内聚, 你不得不将一个大类拆分为多个小类, 每个小类都会具有更高
        的内聚
3.  当修改导致类不再符合单一职权原则时, 应该及时对类进行拆分
4.  类应该符合开放闭合原则, 即对扩展开放, 对修改封闭
5.  类的设计应该符合依赖倒置原则, 即类应当依赖于抽象而不是依赖于具体细节

